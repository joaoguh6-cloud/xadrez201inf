<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jogo de Xadrez - Direção, Cores e Check</title>
  <style>
    :root{--light:#f0d9b5;--dark:#b58863;--accent:#ffef00}
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#222;color:#eee;display:flex;min-height:100vh;align-items:center;justify-content:center}
    #app{width:960px;max-width:96vw}
    .menu{position:relative;background:#111;padding:24px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
    .title{font-size:22px;margin-bottom:12px}
    .controls{display:flex;gap:8px;margin-bottom:12px}
    .btn{background:#2a2a2a;border:1px solid #444;padding:8px 12px;border-radius:8px;cursor:pointer;color:#fff}
    .btn.secondary{background:transparent;border:1px solid #666}

    .board-wrap{display:flex;gap:20px}
    .board{width:640px;height:640px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);border-radius:12px;overflow:hidden}
    .square{position:relative;display:flex;align-items:center;justify-content:center;font-size:34px;user-select:none}
    .square.light{background:var(--light)}
    .square.dark{background:var(--dark)}
    .square .piece{position:relative;width:78%;height:78%;display:flex;align-items:center;justify-content:center;border-radius:8px;font-size:34px}
    .piece.white{background:rgba(255,255,255,0.95);color:#111}
    .piece.black{background:rgba(15,15,15,0.95);color:#fff}
    .piece .dir{position:absolute;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:12px solid rgba(0,0,0,0.7);top:6px;opacity:.9}
    .piece.white .dir{border-bottom-color:rgba(0,0,0,0.85)}
    .piece.black .dir{border-bottom-color:rgba(255,255,255,0.9)}

    .highlight{box-shadow:0 0 0 3px rgba(255,255,0,0.6) inset;border-radius:8px}
    .move-dot{position:absolute;width:12px;height:12px;border-radius:50%;bottom:12px;opacity:.95;border:2px solid rgba(0,0,0,.2)}
    .move-dot.legal{background:rgba(0,180,0,0.9)}
    .move-dot.capture{background:rgba(180,0,0,0.95)}

    .info{width:260px;padding:12px;background:#0f0f0f;border-radius:12px}
    .info h3{margin:0 0 8px}
    .turn{margin-bottom:8px}
    .status{padding:8px;border-radius:8px;background:rgba(255,255,255,0.04)}

    .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center}
    .card{background:#0f0f0f;padding:28px;border-radius:12px;width:520px}
    .card h1{margin:0 0 12px}

    .small{font-size:13px;color:#ccc}
    footer{margin-top:12px;color:#aaa;font-size:12px;text-align:center}
  </style>
</head>
<body>
  <div id="app">
    <div id="menu" class="overlay">
      <div class="card">
        <h1>Jogo de Xadrez</h1>
        <p class="small">Mostra a direção visual de cada peça, cores diferentes para as peças adversárias, indica quando há <strong>check</strong> e traz tela inicial.</p>
        <div style="margin-top:14px;display:flex;gap:8px;align-items:center">
          <label style="display:flex;gap:6px;align-items:center"><input id="flip" type="checkbox"> Virar tabuleiro (preto em baixo)</label>
          <div style="flex:1"></div>
          <button id="startBtn" class="btn">Iniciar partida</button>
        </div>
      </div>
    </div>

    <div class="menu">
      <div class="title">Xadrez — Direção, cores e check</div>
      <div class="controls">
        <button id="restart" class="btn">Reiniciar</button>
        <button id="toggleArrows" class="btn secondary">Alternar setinhas</button>
        <div style="flex:1"></div>
        <div class="small">Clique em uma peça para ver movimentos. Clique em 'Iniciar partida' na tela inicial.</div>
      </div>

      <div class="board-wrap">
        <div id="board" class="board" aria-label="tabuleiro"></div>
        <div class="info">
          <h3>Informações</h3>
          <div class="turn"><strong>Vez:</strong> <span id="turnText">Brancas</span></div>
          <div class="status" id="statusText">Partida pronta</div>
          <div style="margin-top:12px">Peças: <br><span class="small">Brancas têm fundo claro, Pretas têm fundo escuro.</span></div>
          <footer>Feito com JS — básico mas funcional</footer>
        </div>
      </div>
    </div>
  </div>

<script>
  // Representação simples do tabuleiro: 8x8 array
  const initialFEN = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R']
  ];

  let board = [];
  let selected = null;
  let legalMoves = [];
  let turn = 'w'; // 'w' or 'b'
  let showArrows = true;
  let flipped = false;

  const pieceSymbols = {
    'K': '\u2654','Q':'\u2655','R':'\u2656','B':'\u2657','N':'\u2658','P':'\u2659',
    'k':'\u265A','q':'\u265B','r':'\u265C','b':'\u265D','n':'\u265E','p':'\u265F'
  };

  const boardEl = document.getElementById('board');
  const turnText = document.getElementById('turnText');
  const statusText = document.getElementById('statusText');

  function startGame(){
    board = [];
    for(let r=0;r<8;r++){board[r]=[];for(let c=0;c<8;c++){const f = initialFEN[r][c];board[r][c]=f?{type:f,color: (f===f.toUpperCase()?'w':'b')} : null}};
    selected=null;legalMoves=[];turn='w';updateUI();
  }

  function coordToIndex(r,c){return r*8+c}

  function render(){
    boardEl.innerHTML='';
    const rows = [...Array(8).keys()];
    const cols = [...Array(8).keys()];
    const rr = flipped?rows:rows.slice().reverse();
    const cc = flipped?cols.slice().reverse():cols;

    for(let rIndex=0;rIndex<8;rIndex++){
      for(let cIndex=0;cIndex<8;cIndex++){
        const r = rr[rIndex], c = cc[cIndex];
        const sq = document.createElement('div');
        sq.className = 'square ' + (((r+c)%2===0)?'light':'dark');
        sq.dataset.r = r; sq.dataset.c = c;
        const piece = board[r][c];
        if(piece){
          const p = document.createElement('div');
          p.className = 'piece ' + (piece.color==='w'?'white':'black');
          p.innerText = pieceSymbols[piece.type];
          // add direction arrow
          if(showArrows){
            const dir = document.createElement('div');
            dir.className = 'dir';
            // rotate arrow for piece's forward direction (white up, black down)
            dir.style.transform = piece.color==='w' ? 'rotate(0deg)' : 'rotate(180deg)';
            p.appendChild(dir);
          }
          sq.appendChild(p);
        }
        // highlight selection
        if(selected && selected.r==r && selected.c==c){ sq.classList.add('highlight') }
        // show legal dots
        const lm = legalMoves.find(m=>m.r===r && m.c===c);
        if(lm){const dot=document.createElement('div');dot.className='move-dot '+(lm.capture?'capture':'legal');sq.appendChild(dot)}

        sq.addEventListener('click',()=>onSquareClick(r,c));
        boardEl.appendChild(sq);
      }
    }
  }

  function onSquareClick(r,c){
    const piece = board[r][c];
    if(selected){
      // if clicked on a legal move
      const mv = legalMoves.find(m=>m.r===r && m.c===c);
      if(mv){makeMove(selected, mv);selected=null;legalMoves=[];render();checkGameState();return}
    }
    // select piece if of correct color
    if(piece && piece.color===turn){ selected={r,c}; legalMoves = generateLegalMoves(r,c); } else { selected=null; legalMoves=[] }
    render();
  }

  function generateLegalMoves(r,c){
    const piece = board[r][c]; if(!piece) return [];
    const moves = [];
    const own = piece.color;
    const opp = own==='w'?'b':'w';
    const addMove = (nr,nc,capture=false)=>{
      if(nr<0||nr>7||nc<0||nc>7) return;
      // can't capture own
      if(board[nr][nc] && board[nr][nc].color===own) return;
      moves.push({r:nr,c:nc,capture:!!capture});
    }

    const T = piece.type.toLowerCase();
    if(T==='p'){
      const dir = (piece.color==='w')?-1:1;
      // forward
      if(!board[r+dir] || !board[r+dir][c]){ if(isEmpty(r+dir,c)) addMove(r+dir,c,false); }
      // double
      const startRow = piece.color==='w'?6:1;
      if(r===startRow && isEmpty(r+dir,c) && isEmpty(r+2*dir,c)) addMove(r+2*dir,c,false);
      // captures
      for(const dc of [-1,1]){ const nr=r+dir,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8 && board[nr][nc] && board[nr][nc].color===opp) addMove(nr,nc,true) }
    } else if(T==='n'){
      const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
      deltas.forEach(d=>addMove(r+d[0],c+d[1], !!(board[r+d[0]] && board[r+d[0]][c+d[1]])));
    } else if(T==='b' || T==='r' || T==='q'){
      const dirs = [];
      if(T==='b' || T==='q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
      if(T==='r' || T==='q') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
      for(const d of dirs){
        let nr=r+d[0], nc=c+d[1];
        while(nr>=0&&nr<8&&nc>=0&&nc<8){ if(board[nr][nc]){ if(board[nr][nc].color!==own) addMove(nr,nc,true); break } else { addMove(nr,nc,false) } nr+=d[0]; nc+=d[1]; }
      }
    } else if(T==='k'){
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++) if(!(dr===0&&dc===0)) addMove(r+dr,c+dc, !!(board[r+dr] && board[r+dr][c+dc]));
    }

    // filter out moves that leave own king in check
    const legal = moves.filter(m=>{
      const copy = copyBoard(board);
      copy[m.r][m.c] = copy[r][c]; copy[r][c]=null;
      // promotion basic: if pawn reaches last rank, promote to queen
      if(copy[m.r][m.c].type.toLowerCase()==='p' && (m.r===0||m.r===7)) copy[m.r][m.c].type = copy[m.r][m.c].color==='w'?'Q':'q';
      return !isKingInCheck(copy, piece.color);
    });
    return legal;
  }

  function isEmpty(r,c){ return r>=0&&r<8&&c>=0&&c<8 && !board[r][c] }

  function makeMove(from, mv){
    const p = board[from.r][from.c];
    board[mv.r][mv.c] = p; board[from.r][from.c]=null;
    // promotion
    if(p.type.toLowerCase()==='p' && (mv.r===0||mv.r===7)) p.type = p.color==='w'?'Q':'q';
    // switch turn
    turn = (turn==='w')?'b':'w';
    updateUI();
  }

  function copyBoard(b){ const out=[]; for(let r=0;r<8;r++){out[r]=[];for(let c=0;c<8;c++){const v=b[r][c];out[r][c]=v?{type:v.type,color:v.color}:null}} return out }

  function findKingPos(b,color){ for(let r=0;r<8;r++) for(let c=0;c<8;c++){ if(b[r][c] && b[r][c].type.toLowerCase()==='k' && b[r][c].color===color) return {r,c} } return null }

  function isSquareAttackedBy(b, r,c, attackerColor){
    // check knights
    const knightD=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const d of knightD){const nr=r+d[0],nc=c+d[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8 && b[nr][nc] && b[nr][nc].type.toLowerCase()==='n' && b[nr][nc].color===attackerColor) return true}
    // pawns
    const pd = attackerColor==='w'?-1:1; // pawns attack forward relative to their color
    for(const dc of [-1,1]){const nr=r+pd,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8 && b[nr][nc] && b[nr][nc].type.toLowerCase()==='p' && b[nr][nc].color===attackerColor) return true}
    // sliding pieces
    const sliders = [ {dirs:[[1,0],[-1,0],[0,1],[0,-1]],types:['r','q']}, {dirs:[[1,1],[1,-1],[-1,1],[-1,-1]],types:['b','q']} ];
    for(const s of sliders){ for(const d of s.dirs){ let nr=r+d[0], nc=c+d[1]; while(nr>=0&&nr<8&&nc>=0&&nc<8){ if(b[nr][nc]){ if(b[nr][nc].color===attackerColor && s.types.includes(b[nr][nc].type.toLowerCase())) return true; else break } nr+=d[0]; nc+=d[1]; } } }
    // king (adjacent)
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++) if(!(dr===0&&dc===0)){const nr=r+dr,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8 && b[nr][nc] && b[nr][nc].type.toLowerCase()==='k' && b[nr][nc].color===attackerColor) return true}
    return false;
  }

  function isKingInCheck(b,color){ const kp = findKingPos(b,color); if(!kp) return false; return isSquareAttackedBy(b,kp.r,kp.c, color==='w'?'b':'w') }

  function checkGameState(){
    // update status text and mark king square if in check
    const inCheck = isKingInCheck(board, turn);
    if(inCheck){ statusText.innerText = (turn==='w'?'Brancas':'Pretas') + ' estão em CHECK!'; }
    else statusText.innerText = 'Nenhum check';
    render();
    // visually mark king
    const kp = findKingPos(board,turn);
    if(kp){ const idx = kp.r*8+kp.c; // but because render uses flipped mapping, we just highlight square by adding red border
      // simpler: add a red outline to the square element
      const squares = boardEl.querySelectorAll('.square'); squares.forEach(s=>s.style.outline='');
      if(inCheck){
        // find the rendered square for this coord
        for(const sq of boardEl.children){ if(+sq.dataset.r===kp.r && +sq.dataset.c===kp.c){ sq.style.outline='4px solid rgba(255,0,0,0.85)'; sq.style.outlineOffset='-4px'; break } }
      }
    }
  }

  function updateUI(){ turnText.innerText = turn==='w' ? 'Brancas' : 'Pretas'; render(); checkGameState(); }

  // controls
  document.getElementById('restart').addEventListener('click',()=>startGame());
  document.getElementById('toggleArrows').addEventListener('click',()=>{ showArrows = !showArrows; render(); });
  document.getElementById('startBtn').addEventListener('click',()=>{ document.getElementById('menu').style.display='none'; flipped = document.getElementById('flip').checked; startGame(); });

  // initialize minimal
  render();
</script>
</body>
</html>
